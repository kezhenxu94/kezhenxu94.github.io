---
title: 伪共享(False Sharing)及其优化
date: 2020-01-22 22:04:58
updated: 2020-01-22 22:04:58
tags:
  - Java
  - Performance
---

## Background

我们知道, 在计算机运行的过程中, CPU 主要工作就是处理数据, 而存放这些数据的媒介一般分为几个层次, 离 CPU 从"近"到"远"依次是一级缓存(L1), 二级缓存(L2), 三级缓存(L3), (可能还有四级缓存(L4)等等), 内存, 硬盘. 距离 CPU 越近的媒介读写速度越快, 但是价格越昂贵, 因此容量越小; 要想程序运行速度最快, 理想情况下就是把我们所有需要的数据都放到 CPU 缓存上, 但是由于 CPU 缓存容量有限, 所以只能选取"最有价值"的数据"常驻"缓存, 但是"选取"的权力并不在我们手上; 不过我们仍然有一些方法来影响这个决定;

## False Sharing

False Sharing, 伪共享: 在程序运行的过程中, CPU 要处理数据时, 需要先把他们读取到 CPU 缓存中(上文提到的 L1, L2, L3 缓存), 如果 CPU 一直访问同一个数据, 那么情况是最好的, 这一份数据会一直在缓存上被 CPU 访问, 然而情况并非总是这么理想, CPU 处理其他数据时, 可能会把原先缓存的数据刷掉, 换上要处理的新数据; 并且由于 CPU 缓存的最小单位是缓存行(Cache Line, 2 的幂次方, 32, 64, 128 位等), 所以有时候可能为了处理一个 8 位的字符, 需要把整个行都替换掉, 那么原来这个行上的其他缓存数据即使马上就需要被访问了, 也会"受到牵连", 导致被刷掉, 下次需要还得重新加载到缓存, 这就是所谓的"伪共享";

由于缓存的容量有限, 这是不可避免的, 但是当我们有一些数据是极其频繁地需要被访问和更新的时候, 我们希望这些数据能够尽量一直在缓存中, 那么首先需要解决的就是"伪共享"的问题;

解决伪共享的方式也很简单, 只需要保证我们的"目标数据"不要遭受"牵连"就可以了; 由于 CPU 在加载缓存的时候, 会把要访问的数据, 以及它相邻的数据一起加载到缓存上, 凑够一个缓存行, 如果我们能够保证在"目标数据"相邻的一定范围内都是我们控制范围内的数据, 能够填充整个缓存行, 且我们保证不会对他们进行访问和更新, 就能够让"目标数据"不会因为同一行上的其他数据被修改了导致缓存行失效;

## Cache Line Padding

填充!!! 我们可以在"目标数据"前后填充上足够的字节, 让"目标数据"无论怎么被加载, 前后都有足够多的字节来"保护"它, 就能够消除"伪共享"问题;

举个例子, 假设我们在类 `FalseSharing` 中有一个 `long` 类型的变量 `count`:

```java
class FalseSharing {
	long count;
}
```

变量 `count` 在程序中使用非常频繁, 但是我们并不知道变量 `count` 在进入缓存行的时候, 前后都可能有哪些数据存在, 这时候就很有可能出现"伪共享"的问题, 解决方式就是在 `count` 前后填充一些字节, 保证当 `count` 被加载的时候, 前后的字节都是我们已知的, 不会被修改的:

```java
class FalseSharing {
	long p0, p1, p2, p3, p4, p5, p6;
	long count;
	long p8, p9, p10, p11, p12, p13, p14, p15;
}
```

其中 `p0` ~ `p6` 是填充在 `count` 左边, `p8` ~ `p15` 是填充在 `count` 右边, 这样无论缓存行是多少位, 从哪里开始加载数据, 总能保证在 `count` 所在的行都只有它会被修改, 消除了"伪共享"的问题;

为了更好理解上面填充的数量, 可以将缓存行看作一个滑动窗口, `count` 及其前后的数据看作线性排列的字节, 填充后的 `FalseSharing` 类中字节分布可以保证无论缓存行怎么滑动, 行上的变量只有 `count` 一个:

```text
 7 * 8 = 56   (8 bytes)    7 * 8 = 56
+----------+              +----------+
|          |              |          |
+----------+    count     +----------+


+-------------------------+
|                         |
+-------------------------+
cache line(sliding window) 64 bytes
------------------------->
           slide
```

## Practices

消除伪共享在一些对性能非常高的场景下都会使用到, 像 Netty 的 `FastThreadLocal` 其中就使用到了填充的技巧, 来消除伪共享, 类似的还有 [SkyWalking](https://github.com/apache/skywalking) 的 `AtomicRangeInteger` 类, [Disruptor](https://github.com/LMAX-Exchange/disruptor) 等高性能框架, 其中 SkyWalking 相关的 PR 可以在 [GitHub#2930](https://github.com/apache/skywalking/pull/2930) 中看到, 这也是笔者开始了解伪共享的第一个地方;
